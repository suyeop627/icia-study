다형성(Polymorphism)
  부모클래스로 만든 변수에 자식클래스의 인스턴스를 저장하는 것.
  자식클래스에 정의된 모든 기능을 사용하려면 다시 자식클래스로 만든 변수에 인스턴스를 옮겨야 한다.
  (Down Casting)

  instanceof : 어떤 클래스로 만든 인스턴스인지를 구별하기 위한 명령어.

  추상화(Abstraction)
    알고는 있으나 정확하게 표현하기 힘든 것을 설명하는 것 - 추상적 표현

    /추상화를 통해서 상위개체와 하위 개체를 만들 수 있다.
    동물은 어떻게 울까?
    구체적으로 동물의 울음 소리는 종마다, 개체마다 다르겠지만 일단 울음소리를 낸다.
    모든 동물의 울음소리를 한번에 다 정의하긴 어렵지만, 동물은 울음소리를 낸다는 것을 먼저 정의하고
    각 동물마다 특정 울음소리를 구체화할 수 있다.


  개념클래스 작성 - 추상화 -> 추상 클래스(Abstract)

  비접근제어자 - static, final, abstract

  추상 클래스 : 미완성 클래스
  완성 클래스? -> 모든 멤버 메소드의 정의가 완전히 정의된 클래스
  추상 메소드 : 정의부가 작성되지 않은 메소드.

  봔환형 메소드명()      <- 선언부
  ------------------------------
  {
  .......             <- 정의부
  }

 / 선언부만 작성하면 에러 발생,
  abstract 반환형 메소드명();   의 형식으로 작성하면 선언부만 작성하는 것이 가능해짐


 /추상메소드도 결국 완성은 돼야함
 ex) 자동차 제작 시, 타이어가 들어간다. -> 자동차의 크기, 차종 등에 따라 타이어의 규격이 달라짐.
    -> 각 차종마다 타이어의 규격을 새로 정의해야함
    -> 자동차의 실제 제작단계에서 타이어의 규격을 재정의.


 추상 클래스는 반드시 상속하여 자식클래스로 만들어서 사용하며, 이때, 완성된 메소드의 정의부를 작성해야 한다.


추상 클래스는 팀장이 팀원에게 일을 주는 경우에 많이 사용됨.
오버라이딩을 강제하기 때문에, 정해진 메소드 이름으로 새로운 클래스를 작성하도록 하여 전체 프로젝트를 병렬화할 수 있음
A, B, C가 같이 작업을 할때, B, C에서 사용될 메서드를 A에서 작업할 경우, A의 작업이 끝나야 B와 C가 일을 시작할 수 있다.
추상화를 활용하면, B와 C에서 A가 작업중인 메서드를 상속받아 활용할 수 있다.


인터페이스 (Interface)
  추상화 정도가 더 심한 클래스
  개념이나 용어들만 정의.
  모든 메소드가 정의되지 않은 클래스.
  추상 메소드 + 상수( = final 변수)만 들어가 있다.
  인스턴스를 생성할 수 없다.
  목적은 새로운 클래스 작성에 도움을 주는 것.
  클래스 작성의 표준을 제시하는 것.

  코드 자동화(프레임 워크) - 프레임워크를 활용하면 코드를 자동으로 생성할 수 있다.
   인터페이스는 프레임워크에서 활용된다.

 어떤 연산과 출력을 함께 해야하는 상황에서, 출력을 어디에 해야할지는 프로젝트에 따라 달라짐.
 출력 클래스를 인터페이스로 해서 해당 코드를 활용할 때, 출력클래스를 새로 작성하도록.


  +)추상화는 미완성된 부분도 있지만, 완성된 부분도 존재 - 인터페이스는 전부 미완성

  인터페이스의 작성법
  1) class 라는 키워드 대신 interface 사용
  2) 모든 메소드는 추상 메소드이며 재정의가 되어야 하기 때문에 public abstract가 앞에 붙는다. 메소드는 정의하지 않는다.
  3) 모든 변수에는 public static final 이 앞에 붇는다.
  4) 반드시 붙어야 하는 키워드는 생략할 수 있다.(메소드의 public abstract 또는 public static final 을 생략할 수 있다.)



제어자 간 조합
1. 메소드에 static 과 abstract 를 함께 사용할 수 없다. => 인스턴스 없이 사용하려고 해도, 정의부가 없어서 실행 할 수 없다.
  static - 인스턴스 없이 사용 가능
  abstract - 정의부가 없다.

2. 클래스에 abstract와 final 을 함께 사용할 수 없다.
  abstract - 반드시 상속을 해야 한다.
  final - 상속 불가

3. abstract 메소드의 접근제어자가 private일 수 없다.
  private 는 상속해도 사용할 수 없다.
  abstract 는 재정의를 해야한다.
4. 메소드에 private와 final을 같이 사용할 필요가 없다.
  private은 상속해도 못쓰고, final은 상속 불가 - private과 final은 둘다 overriding 불가.
=> private하나로 모두 처리될 수 있기 때문.


일반적인 작성 순서
  접근제어자, 비접근 제어자 순서로 작성.

 제어자의 대상

 1) 클래스 - 접근제어자, abstract, final
 2) 메소드 - 접근 제어자, final, abstract, static   (모든 제어자를 사용할 수 있다.)
 3) 멤버변수 - 접근제어자, final, static
 4) 지역변수 - final


Inner Class(내부 클래스)
  클래스 내부에 작성하는 클래스. 클래스가 멤버가 된다.
  장점 > 외부 클래스의 멤버를 자유롭게 사용 가능해진다.

익명 클래스
  인터페이스로 새로운 클래스를 파생시킬 때, 클래스의 이름없이 바로 작성하여 인스턴스를 생성하는 클래스
  클래스의 이름이 없기 때문에 익명클래스라고 함.
  GUI 프로그래밍, 안드로이드 프로그래밍에서 많이 사용하는 방식.
  1회용, 전용 기능을 작성할 때 주로 사용.

ArrayList <- List 인터페이스의 자손클래스


객체 지향 특성
1. 캡슐화(정보은닉) - 클래스 작성.
2. 상속 - 기존 코드의 재활용.
3. 다형성 - 계층 구조로 만든 객체를 효율적으로 관리.
4. 추상화 - 개념에 대한 설계.

기타 유용한 객체들
문자열(String)
  1) equals() : 두 문자열 변수에 저장된 실제 데이터의 비교. (참조변수의 값이 같은지를 비교하는건 의미가 없으므로, 참조하고 있는 실제 데이터를 확인해서 값을 비교함)

      2) concat() : 두 문자열을 결합. '+'와 같음.
      3) charAt() : 문자열 내의 문자 위치 찾기   (length -1로 해야함. Strign도 순번은 0부터)
      4) contains(str) : str이 있으면 true, 없으면 false
      5) indexof(str) : str이 있으면 시작 위치를, 없으면 -1.
                        n은 검색 시작 위치(생략하면 처음부터)
      6) split(구분자) : 구분자에 따라 문자열을 문자열 배열로 변환
      7) replace(str1, str2) : 모든 str1을 str2로 변환
            replaceAll(str1, str2) : 모든 str1을 str2로 변환, str1에 수식을 사용. '['와']'사이에 다음의 키워드를 입력.
                                    ^ : not. str1을 제와한 나머지를 변경
                                    - : 범위를 지정. 예) 0-9 : 모든 숫자
                                       // System.out.println(str7.replaceAll("[0-9]", " ")); 모든 숫자의 위치를 공백으로 변경

      8) length() : 문자열의 길이.
      9) subString(start, end) : start부터 end(idx)직전까지의 문자열 추출       start<end 가 항상 성립한다.



 +)
  String a = "abc"
  a = "xyz"

  String타입은 위 처럼 변수의 값을 바꿀 때, 값을 지우고 새 값을 넣는게 아니라 abc를 참조하던 걸 xyz 참조로 바꿈
  abc는 가비지 컬렉터가 치워준다.
  "abc"의 주소를 가지고 있던 a에 "xyz"의 주소를 넣는 형태. 실제 값이 저장된 위치에서의 갑 변경은 이루어지지 않는다.



StringBuffer
    임시 저장고. 문자열의 수정, 변경 등의 작업의 효율성을 높이는 보조 객체.(String을 보조하기 위한 객체)
    문자들의 배열을 잠깐 만들어서 수정이나 제거같은거 하는 공간?

  String a = "abc"
  a = "xyz"

   위 라인에서,  문자열을 처리할 수 잇는 큰 공간(buffer)를 만들어서 abc를 실제로 지우고 xyz를 사용함
   abc에 +xyz를 한다면? -> buffer가 없다면?-> abcxyz라고 저장된 새로운 공간을 만들어서 해당 공간의 주소를 a에 반환
   StringBuffer를 사용하면 -> buffer에 abc에 xyz를 바로 붙일 수 있음(메모리 공간을 보다 효율적으로 처리)

StringBuffer
    1) append(str) : 버퍼에 새 문자열을 추가. (뒤에 붙인다.)
    2) capacity() : 용량. 버퍼의 크기를 구함
    3) length() : 버퍼 안의 문자열에 크기
    4) delete(st, ed) : 지정된 범위의 문자열 삭제
    5) insert(idx, str) : 지정된 위치(idx)에 str 삽입.(완성된 문자열이 아니므로 중간 삽입이 가능하다. (문자열은 그자체로 하나라서 불가능)
    6) replace(st, ed, str) : 지정된 범위의 문자열을 str로 변경.
    7) reverse() : 문자열의 순서를 역순으로 정렬.
    8) charAt(idx) : 지정된 위치의 문자를 가져온다.
    9) setCharAt(idx, char) : 지정된 위치에 문자를 변경한다.



파일(file)

날짜와 시간


/////////////
배운거 종합해서 일기장 만들기




















